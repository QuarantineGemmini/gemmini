#!/usr/bin/env python

# SIMPLE 1st pass

import re
import sys
import os
from textwrap import dedent as dd
import argparse



#=============================================================================
# subroutines
#=============================================================================
def print_usage():
	print("""
  gemmini_trace_munge <in_log> [options]
  --------------------------------------
  Reads a log file from a gemmini RTL simulator (vcs, verilator, firesim),
  and does a variety of actions on it, including verification of dependencies,
  and generating various waveforms (wavedrom json, vcd, excel, ascii).

  options
  -------
  -wavedrom_out <json>    --> generate a json for wavedrom consumption
  -h|-help                --> print this help
	"""))
	exit(1)

#=============================================================================
# parse args
#=============================================================================
class GemminiCommandParams(NamedTuple):
  accept_cycle
  issue_cycle
  final_cycle
  entry_id
  cmd_id

class Queue(Enum)
  Exec = 0
  Load = 1
  Store = 2

class Addr(abc):
  def __init__

class DramAddr



class GemminiTrace():
  def __init__(self, log_file, entries):
    self._log_file = log_file
    self._entries = entries
    self._read_log_file()

  def _read_log_file(self)
    pending_accepts = [None for x in range(self._entries)]
    pending_issues  = [None for x in range(self._entries)]
    commands        = []

    with open(self._log_file, "r") as f:
      for line in f:
        m = re.match("^cycle\[\s*(\d+)\],\s+entry\[\s*(\d+)\],\s+(\S.*)$", line)
        if m is None:
          next
        cycle    = m[1]
        entry_id = m[2]
        rest     = m[3]

        m = re.match("^(accept|issue|final)\[\s*(\d+)\], (\S.*)$", rest)
        if m is None:
          next
        event  = m[1]
        cmd_id = m[2]
        rest   = m[3]
        
        if event == "accept":
          if (pending_accepts[entry_id] is not None) or
              (pending_issues[entry_id] is not None):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} accepted into occupied entry_id"))
          else:
            pending_accepts[entry_id] = {
                "cycle": cycle,
                "cmd_id": cmd
              }
          pass

        elif event == "issue":
          cmd_type = rest
          if (pending_accepts[entry_id] is None):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} issued but not accepted"))
          elif (pending_issues[entry_id] is not None):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} issued into occupied slot"))
          elif (pending_accepts[entry_id]["cmd_id"] != cmd_id):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} does not match pending-accept cmd_id"))
          elif (pending_accepts[entry_id]["cmd_type"] != cmd_type):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} does not match pending-accept cmd_type"))
          elif (pending_accepts[entry_id]["cycle"] >= cycle):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} occurs on or before its accepted cycle"))
          pending_issues[entry_id] = {
              "cycle": cycle,
              "cmd_id": cmd_id,
              "cmd_type": cmd_type
            }
        else:
          # event == "final"
          cmd_type = rest
          if (pending_issues[entry_id] is None):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} finalized but not issued"))
          elif (pending_issues[entry_id]["cmd_id"] != cmd_id):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} does not match pending-issue cmd_id"))
          elif (pending_issues[entry_id]["cmd_type"] != cmd_type):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} does not match pending-issue cmd_type"))
          elif (pending_issues[entry_id]["cycle"] > cycle):
            errors.append(GemminiTraceError(
              cycle=cycle,
              entry_id=entry_id,
              msg=f"{cmd_id} occurs on or before its issued cycle"))

          ae = pending_accepts[entry_id]
          ie = pending_issues[entry_id]
          commands.append(GemminiCommand(
            accept_cycle=ae["cycle"],
            issue_cycle=ie["cycle"],
            final_cycle=cycle,
            entry_id=entry_id,
            cmd_id=cmd_id,
            params=ae["params"]))

class GemminiCommand(abc):
  @property
  def __init__(self, accept_cycle, issue_cycle, final_cycle, 
      entry_id, cmd_id, params):
    self.accept_cycle = accept_cycle
    self.issue_cycle = issue_cycle
    self.final_cycle = final_cycle
    self.entry_id = entry_id
    self.cmd_id = cmd_id
    self.params = params

  def get_dependencies(,self):
    """the label to show in the pending portion"""
    # if in same queue, list the latest one accepted before it
    # - all issues must be in same order, and all finals must be in same order
    # if in different queue but RAW, RAW, or WAW (dram OR spad) point to it
    # - all issues must come after final of dependency

  @abstractmethod
  def pending_label(self):
    """the label to show in the pending portion"""
    pass

  @abstractmethod
  def active_label(self):
    """the label to show in the active portion"""
    pass

class ExCommand(GemminiCommand):



#=============================================================================
if __name__ == "__main__":
	if len(sys.argv) < 1:
		print_usage()

	# parse inputs
	in_file = sys.argv[1]
	out_file = sys.argv[2]
	trigger = re.compile(".*`ifdef PRINTF_COND.*")
	targets = []
	for idx in range(3, len(sys.argv)):
		targets.append(re.compile(sys.argv[idx]))

	# read input lines
	in_lines = []
	with open(in_file, "r") as f:
		in_lines = f.readlines()

	# enable PRINTF_COND lines around points of interest
	enables = 0
	out_lines = []
	idx = 0
	idx_end = len(in_lines)
	while(idx < idx_end):
		if trigger.match(in_lines[idx]):
			matches_target = False
			for target in targets:
				if target.match(in_lines[idx+4]):
					matches_target = True
					break
			if matches_target:
				enables += 1
				out_lines += in_lines[idx+3:idx+6]
			else:
				out_lines += in_lines[idx:idx+9]
			idx += 9
		else:
			out_lines.append(in_lines[idx])
			idx += 1

	# write to output file
	with open(out_file, "w") as f:
		f.writelines(out_lines)

	print(f"INFO: enabled {enables} printfs in {out_file}")

if __name__ == "__main__":
  if len(sys.argv


  # parse args

  #read file

  #filter lines and convert to data-structure

  #convert data-structure to json

  #write json to stdout

